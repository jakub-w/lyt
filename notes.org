* Notes
** Backend/API (C++)
auto query = yt.Search("foo");
query = yt.Search("foo").Order(yt::DATE_ORDER).MaxResults(10);
query.Perform();

This is how .NET does that.

This is the library part. It could be called liblyt (leloYT).

yt.Search(), yt.Videos(), yt.Thumbnails() and other base operations each would return their dedicated objects of class derived from BaseOperation (which is inheriting OperationInterface) that would define functions to set parameters of the query.

Perform() function is defined in BaseOperation and it collects all the set perameters, creates a query and sends it.

Each concrete Operation class has to define set of functions that modify parameters map (parameters_).
For Operations to be savable and modifiable they should store query parameters in variables and generate the query on Perform().
They will be stored in a map. The declaration of this map is in the BaseOperation class.

Perform() is a method defined in each concrete Operation class since every Operation wants to return concrete Response object that corresponds to it.

QuerySend takes Query object argument because all of the parameters should be escaped before performing a libcurl request and to do that, CURL context is needed.

For parsing json rapidjson is used because of its speed. It's licensed under MIT license.
Documentation for it: [[https://miloyip.gitbooks.io/rapidjson/content/en/][here]].

CURLcontext has a template method Get() that returns specified unique pointer to object of class that inherits yt::Response (it checks type with ~static_assert~).
Internally, it calls Get_() that sends the query and returns CURLresponse object storing uri and response content.
Get_() exists because it's a long method that shouldn't be compiled multiple times for multiple return types since it doesn't care what class the user wants to use for output.
Every Operation class will have to call CURLcontext::Get() with a type that it wants to store the CURL response in.

Operations should return Responses of a specific type. We want to be explicit for the sake of Scheme integration. /(Is that so?)/

*speculation*
For now, only video extraction is supported so it would be advised to include type=video as a parameter to the query because now it searches for everything - videos, playlists and channels.
Maybe SearchOperation should have Type() function that would take not only those three choices (as an enum) but also ALL that would search for all types (it would remove type parameter from the parameter list)

Maybe it would be better to create setters for Video class' data members so it would be possibile to add additional information about a video. That would eliminate that awful constructor with million arguments.
Alternatively create a struct for a constructor (VideoInfo or something).
** CLI (C++)
yt search "foo"
yt search --order date --max-results 10 "foo"

Some operations require authentication so we could have a daemon running a session for that.

Maybe use Guile also for the CLI? [[https://www.gnu.org/software/guile/manual/html_node/Command-Line-Handling.html][Link to manual]]

** TUI (Guile)
There are [[https://www.gnu.org/software/guile-ncurses/][ncurses bindings for guile]], so the whole TUI (text-based user interface) could be written in it.

[[info:guile-ncurses#Curses%20Tutorial][Guile Curses Tutorial]]

(yt-search "foo")
(yt-search "foo" :order 'date :max-results 10)

* TO DO
** IN-PROGRESS Working, basic search for YouTube [2/4]
*** DONE Video class
CLOSED: [2018-11-29 czw 21:15]
*** DONE Refactor Response [4/4]
CLOSED: [2019-01-29 wto 16:01]
**** DONE Refactor Query class
CLOSED: [2018-12-01 sob 15:56]
**** DONE Add extracting videos stuff to SearchResponse
CLOSED: [2018-12-01 sob 16:03]
**** DONE Remove extracting videos stuff from Response
CLOSED: [2018-12-01 sob 17:06]
Maybe make it an abstract class.
**** DONE Find a way to return certain Response objects with CURLcontext (Create Data class with SearchData inheriting from it)
CLOSED: [2019-01-29 wto 16:01]
Response class should contain some data structure that is inherent to only the certain type of response. This would mean that creating child classes of Response would be not necessary. Just create this Data interface and SearchData and so could be an instance of it.
*** TODO VideosOperation
[[*VideosOperation][VideosOperation]]
**** Parameters [0/2]
***** TODO [[*part][part]]
At least ~snippet~ parameter.
***** TODO [[*id][id]]
*** WAITING JSON parsing [3/5]
**** DONE Modify Response class to parse server response to rapidjson::Document
CLOSED: [2018-11-30 pią 16:10]
**** DONE Create a way to extract videos as Video objects from Response
CLOSED: [2018-11-30 pią 23:32]
Response::GetVideos() or something like that
**** DONE [BUG] Escape parameters before sending a query
CLOSED: [2018-12-01 sob 00:08]
libcurl doesn't escape spaces in an url, it can be done by using curl_easy_escape(), but it requires CURL handle
[[file:BaseOperation.cpp:://%20FIXME:%20every%20parameter%20value%20should%20be%20escaped][Here]]
**** TODO Get ids from received video list and create request for those videos to get titles and descriptions
SearchOperation returns a list of items that can be of different type like channel, playlist or video. We could show only results that have id->videoId parameter (channel would have only channelId).
Or we could use ~type=video~ parameter by default when invoking SearchOperation.

If video description is long, SearchOperation will return only part of it, so we could call VideosOperation if ~description~ parameter ends with "..." or make it an option to show the entire description.
Thumbnail list is also longer in VideosOperation.
** TODO Refactor Video class
Maybe it would be better to create setters for Video class' data members so it would be possibile to add additional information about a video. That would eliminate that awful constructor with million arguments.
** TODO Operations
*** TODO SearchOperation [0/2]
[[https://developers.google.com/youtube/v3/docs/search/list][API Reference]]

NOTE: some of the functions would have exactly the same code with different variable names. They should be using a common function.
(Example: ChannelId just adds the given variable value to a query)
**** TODO Parameters [12%]
***** DONE part
CLOSED: [2018-11-19 pon 22:32]
***** TODO forContentOwner
***** TODO forDeveloper
***** TODO forMine
***** TODO relatedToVideoId
***** DONE channelId
CLOSED: [2018-11-19 pon 22:32]
***** TODO channelType
***** TODO eventType
***** TODO location
***** TODO locationRadius
***** DONE maxResults
CLOSED: [2018-11-19 pon 22:32]
***** TODO onBehalfOfContentOwner
***** TODO order
***** TODO pageToken
***** TODO publishedAfter
***** TODO publishedBefore
***** DONE q
CLOSED: [2018-11-19 pon 22:31]
***** TODO regionCode
***** TODO relevanceLanguage
***** TODO safeSearch
***** TODO topicId
***** TODO type
***** TODO videoCaption
***** TODO videoCategoryId
***** TODO videoDefinition
***** TODO videoDimension
***** TODO videoDuration
***** TODO videoEmbeddable
***** TODO videoLicense
***** TODO videoSyndicated
***** TODO videoType

**** TODO Response [0%]
***** TODO kind
***** TODO etag
***** TODO nextPageToken
***** TODO prevPageToken
***** TODO regionCode
***** TODO pageInfo
***** TODO pageInfo.totalResults
***** TODO pageInfo.resultsPerPage
***** TODO items[]
*** TODO VideosOperation
**** TODO Parameters [0%]
***** TODO part
****** TODO contentDetails
****** TODO fileDetails
****** TODO id
****** TODO liveStreamingDetails
****** TODO localizations
****** TODO player
****** TODO processingDetails
****** TODO recordingDetails
****** TODO snippet
****** TODO statistics
****** TODO status
****** TODO suggestions
****** TODO topicDetails
***** TODO chart
***** TODO id
***** TODO myRating
***** TODO hl
***** TODO maxHeight
***** TODO maxResults
***** TODO maxWidth
***** TODO onBehalfOfContentOwner
***** TODO pageToken
***** TODO regionCode
***** TODO videoCategoryId
**** TODO Response [%]
***** TODO kind
***** TODO etag
***** TODO nextPageToken
***** TODO prevPageToken
***** TODO pageInfo
***** TODO pageInfo.totalResults
***** TODO pageInfo.resultsPerPage
***** TODO items[]
